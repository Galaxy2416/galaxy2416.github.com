
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  
    <title>Effective C++ | IcePie&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="冰派">
    

    
    <meta name="description" content="Effective C++ 之55个小技巧Accustoming Yourself to C++ Item 01C++ &#x3D; C + OOC + template + STL Item 02尽量用 const, enum, inline 替换 #define Item 03 尽可能的使用 const 常亮 指针 函数  两个概念：  bitwise constness(C++使用)  logical">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="http://galaxy2416.github.io/2018/02/23/cpp-effective/index.html">
<meta property="og:site_name" content="IcePie&#39;s blog">
<meta property="og:description" content="Effective C++ 之55个小技巧Accustoming Yourself to C++ Item 01C++ &#x3D; C + OOC + template + STL Item 02尽量用 const, enum, inline 替换 #define Item 03 尽可能的使用 const 常亮 指针 函数  两个概念：  bitwise constness(C++使用)  logical">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-02-22T17:19:24.000Z">
<meta property="article:modified_time" content="2021-09-26T02:51:38.965Z">
<meta property="article:author" content="冰派">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="IcePie&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/planets/planet_earth_venues_univearse_jupiter.png">
    
    
    <link rel="apple-touch-icon" href="/img/planets/planet_earth_venues_univearse_jupiter.png">
    <link rel="apple-touch-icon-precomposed" href="/img/planets/planet_earth_venues_univearse_jupiter.png">
    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/%02.css">
<link rel="stylesheet" href="/.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/planets/planet_univearse_telestial_space_pluto.png" alt="IcePie&#39;s blog" title="IcePie&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="IcePie&#39;s blog">IcePie&#39;s blog</a></h1>
				<h2 class="blog-motto">语不惊人死不休</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:galaxy2416.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/02/23/cpp-effective/" title="Effective C++" itemprop="url">Effective C++</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="冰派" target="_blank" itemprop="author">冰派</a>
		
  <p class="article-time">
    <time datetime="2018-02-22T17:19:24.000Z" itemprop="datePublished"> 发表于 2018-02-23</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="Effective-C-之55个小技巧"><a href="#Effective-C-之55个小技巧" class="headerlink" title="Effective C++ 之55个小技巧"></a>Effective C++ 之55个小技巧</h1><h2 id="Accustoming-Yourself-to-C"><a href="#Accustoming-Yourself-to-C" class="headerlink" title="Accustoming Yourself to C++"></a>Accustoming Yourself to C++</h2><!---more--->
<h3 id="Item-01"><a href="#Item-01" class="headerlink" title="Item 01"></a>Item 01</h3><p>C++ = C + OOC + template + STL</p>
<h3 id="Item-02"><a href="#Item-02" class="headerlink" title="Item 02"></a>Item 02</h3><p>尽量用 const, enum, inline 替换 #define</p>
<h3 id="Item-03-尽可能的使用-const"><a href="#Item-03-尽可能的使用-const" class="headerlink" title="Item 03 尽可能的使用 const"></a>Item 03 尽可能的使用 const</h3><ol>
<li>常亮</li>
<li>指针</li>
<li>函数</li>
</ol>
<p>两个概念：</p>
<ul>
<li>bitwise constness(C++使用) </li>
<li>logical constness (使用mutible来实现)</li>
</ul>
<p>const_cast 可以作为转型解除掉const</p>
<h3 id="Item-04-确认对象使用前已经被初始化"><a href="#Item-04-确认对象使用前已经被初始化" class="headerlink" title="Item 04 确认对象使用前已经被初始化"></a>Item 04 确认对象使用前已经被初始化</h3><ul>
<li>为内置对象进行手工初始化，因为C++不保证他们。</li>
<li>构造函数最好使用成员初始化列表。排列顺序应该和生命顺序一致。</li>
</ul>
<p>技巧：使用 member initialization list</p>
<pre><code>dom::function()
:member1(xxx)
:member2(xxx)
.....
</code></pre>
<ul>
<li>为免除“跨编译单元之初始化次序”问题，用local static对象替代non-local static对象。</li>
</ul>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="Item-05-了解C-默默编写并调用哪些函数"><a href="#Item-05-了解C-默默编写并调用哪些函数" class="headerlink" title="Item 05 了解C++默默编写并调用哪些函数"></a>Item 05 了解C++默默编写并调用哪些函数</h3><ul>
<li>编译器会暗自为class创建default创建构造，copy构造，copy assignment操作符，以及析构函数。</li>
</ul>
<h3 id="Item-06-不想使用编译器自动生成的函数，应该明确拒绝"><a href="#Item-06-不想使用编译器自动生成的函数，应该明确拒绝" class="headerlink" title="Item 06 不想使用编译器自动生成的函数，应该明确拒绝"></a>Item 06 不想使用编译器自动生成的函数，应该明确拒绝</h3><ul>
<li>设置为private或者使用Uncopyable这种base class也是一种做法。</li>
<li>C++ 14 提供了delete的函数。</li>
</ul>
<h3 id="Item-07-对多态基类声明-virtual-析构函数"><a href="#Item-07-对多态基类声明-virtual-析构函数" class="headerlink" title="Item 07 对多态基类声明 virtual 析构函数"></a>Item 07 对多态基类声明 virtual 析构函数</h3><ul>
<li>polymorphic base class应该声明一个virtual析构函数，如果class带有任何virtual函数，他就应该拥有一个virtual函数。</li>
<li>classes的设计目的如果不是作为base classs使用， 或者不是为了具备polymorphically， 就不应该声明virtual析构函数。</li>
</ul>
<h3 id="Item-08-别让异常逃离析构函数"><a href="#Item-08-别让异常逃离析构函数" class="headerlink" title="Item 08 别让异常逃离析构函数"></a>Item 08 别让异常逃离析构函数</h3><ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或程序结束。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（非在析构函数中）执行该操作。</li>
</ul>
<h3 id="Item-09-绝不在构造和析构过程中调用virtual函数"><a href="#Item-09-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="Item 09 绝不在构造和析构过程中调用virtual函数"></a>Item 09 绝不在构造和析构过程中调用virtual函数</h3><ul>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造和析构函数的那层）</li>
</ul>
<h3 id="Item-11-在operator-中处理“自我赋值”"><a href="#Item-11-在operator-中处理“自我赋值”" class="headerlink" title="Item 11 在operator=中处理“自我赋值”"></a>Item 11 在operator=中处理“自我赋值”</h3><pre><code>Class&amp; Class::operator=(const Class&amp; rhs)
&#123;
    if (this == &amp;rhs) return *this // 认同测试
    ……        
    return *this
&#125;
</code></pre>
<ul>
<li>确保当对象自我赋值时 operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li>
</ul>
<p>copy-and-swap 技术和“异常安全性”有密切的联系。</p>
<ul>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
<h3 id="Item-12-复制对象时勿忘其每一个成分"><a href="#Item-12-复制对象时勿忘其每一个成分" class="headerlink" title="Item 12 复制对象时勿忘其每一个成分"></a>Item 12 复制对象时勿忘其每一个成分</h3><ul>
<li>Copying函数应该确保复制“对象内的所有成员变量”以及”所有base class成分”。</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</li>
</ul>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="Item-13-以对象管理资源"><a href="#Item-13-以对象管理资源" class="headerlink" title="Item 13 以对象管理资源"></a>Item 13 以对象管理资源</h3><ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr （实际上已经在C++11之后的标准库中），shared的行为通常比较直观。auto_ptr会使被复制物为null，因此在新版本中尽量不宜使用。</li>
</ul>
<h3 id="Item-14-在资源管理类中小心copying行为"><a href="#Item-14-在资源管理类中小心copying行为" class="headerlink" title="Item 14 在资源管理类中小心copying行为"></a>Item 14 在资源管理类中小心copying行为</h3><ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying 行为是: 抑制 copying、施行计数法（reference counting）。不过其他行为也都可能被实现。</li>
</ul>
<h3 id="Item-15-在资源管理类中体工队原始资源的访问"><a href="#Item-15-在资源管理类中体工队原始资源的访问" class="headerlink" title="Item 15 在资源管理类中体工队原始资源的访问"></a>Item 15 在资源管理类中体工队原始资源的访问</h3><ul>
<li>API往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换后者隐式转换（operator()隐式转换函数）。显式转换更安全，隐式转换对客户比较方便。</li>
</ul>
<h3 id="Item-16-成对使用new和delete时要采取相同的形式"><a href="#Item-16-成对使用new和delete时要采取相同的形式" class="headerlink" title="Item 16 成对使用new和delete时要采取相同的形式"></a>Item 16 成对使用new和delete时要采取相同的形式</h3><ul>
<li>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</li>
</ul>
<h3 id="Item-17-以独立语句讲newed对象置入智能指针"><a href="#Item-17-以独立语句讲newed对象置入智能指针" class="headerlink" title="Item 17 以独立语句讲newed对象置入智能指针"></a>Item 17 以独立语句讲newed对象置入智能指针</h3><p>Java和C#都是以特定的次序完成函数参数的核算。</p>
<ul>
<li>以独立语句将newed对象存储于（置于）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</li>
</ul>
<p>分离语句：</p>
<pre><code>shared_ptr&lt;xx&gt; pw(new xx);
process(pw,.....);
</code></pre>
<p>因为可能new后的指针还未被管理，因为其他事情（顺序不确定）而导致异常。</p>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="Item-18-让接口容易被正确使用，不容易被误用"><a href="#Item-18-让接口容易被正确使用，不容易被误用" class="headerlink" title="Item 18 让接口容易被正确使用，不容易被误用"></a>Item 18 让接口容易被正确使用，不容易被误用</h3><ul>
<li>好的接口容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止使用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互锁问题。（把Unlock作为deleter）</li>
</ul>
<h3 id="Item-19-设计class有如设计type"><a href="#Item-19-设计class有如设计type" class="headerlink" title="Item 19 设计class有如设计type"></a>Item 19 设计class有如设计type</h3><ul>
<li>新的type对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新type的对象如果被passed by value，意味着什么？</li>
<li>什么是新type的“合法值”？</li>
<li>你的新type需要配合某个inheritance graph吗？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新type的成员？</li>
<li>什么是新type的“未声明接口”</li>
<li>你的新type有多么一般化？</li>
</ul>
<h3 id="Item-20-宁以pass-by-reference-to-const-替换-pass-by-value"><a href="#Item-20-宁以pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="Item 20 宁以pass-by-reference-to-const 替换 pass-by-value"></a>Item 20 宁以pass-by-reference-to-const 替换 pass-by-value</h3><ul>
<li>尽量以pass-by-reference-to-const 替换 pass-by-value。 前者通常比较高效，并且可以避免切割问题（slicing problem）</li>
<li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对他们而言，pass-by-value往往比较适当。</li>
</ul>
<h3 id="Item-21-必须返回对象时，别忘想返回其reference"><a href="#Item-21-必须返回对象时，别忘想返回其reference" class="headerlink" title="Item 21 必须返回对象时，别忘想返回其reference"></a>Item 21 必须返回对象时，别忘想返回其reference</h3><ul>
<li>绝对不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</li>
</ul>
<h3 id="Item-22-将成员变量声明为private"><a href="#Item-22-将成员变量声明为private" class="headerlink" title="Item 22 将成员变量声明为private"></a>Item 22 将成员变量声明为private</h3><ul>
<li>切忌将成员变量声明为private。</li>
<li>protected 并不比 public更具有封装性。</li>
</ul>
<h3 id="Item-23-宁以non-member、non-friend替换member函数。"><a href="#Item-23-宁以non-member、non-friend替换member函数。" class="headerlink" title="Item 23 宁以non-member、non-friend替换member函数。"></a>Item 23 宁以non-member、non-friend替换member函数。</h3><ul>
<li>这样做可以增加封装性、包裹弹性和技能扩充性。</li>
</ul>
<h3 id="Item-24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#Item-24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="Item 24 若所有参数皆需类型转换，请为此采用non-member函数"></a>Item 24 若所有参数皆需类型转换，请为此采用non-member函数</h3><ul>
<li>如果需要为某个函数的所有参数（包括被this所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</li>
</ul>
<p>比如 result = rational * 2 和 result = 2 * rational</p>
<h3 id="Item-25-考虑写出一个不抛异常的swap函数"><a href="#Item-25-考虑写出一个不抛异常的swap函数" class="headerlink" title="Item 25 考虑写出一个不抛异常的swap函数"></a>Item 25 考虑写出一个不抛异常的swap函数</h3><p>pimpl方法， pointer to implementation</p>
<p>前提知识点：template的偏特化和全特化。</p>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap 用来调用前者。对于class（而非templated）， 也请特化std:swap。</li>
<li> 调用swap时应针对std::swap使用using声明，然后调用swap并且不带任何“命名空间资格修饰”。</li>
<li> 为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Item-26-尽可能延后变量定义式的出现时间"><a href="#Item-26-尽可能延后变量定义式的出现时间" class="headerlink" title="Item 26 尽可能延后变量定义式的出现时间"></a>Item 26 尽可能延后变量定义式的出现时间</h3><ul>
<li>增加程序的清晰度并且改善程序的效率。</li>
</ul>
<h3 id="Item-27-尽量少做转型工作"><a href="#Item-27-尽量少做转型工作" class="headerlink" title="Item 27 尽量少做转型工作"></a>Item 27 尽量少做转型工作</h3><p>四种转型：</p>
<ol>
<li>const_cast</li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
<li>static_cast</li>
</ol>
<ul>
<li>如果可以，尽量避免转型，特别在注重效率的代码中避免dynamic_castes。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它影藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。</li>
<li>宁可使用C++-style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的执掌。</li>
</ul>
<h3 id="Item-28-避免返回handles指向对象内部成分"><a href="#Item-28-避免返回handles指向对象内部成分" class="headerlink" title="Item 28 避免返回handles指向对象内部成分"></a>Item 28 避免返回handles指向对象内部成分</h3><ul>
<li>增加封装性，帮助const成员函数的行为像是const，并将发生 dangling handles的可能性降至最低。</li>
</ul>
<h3 id="Item-29-为“异常安全”而努力是值得的"><a href="#Item-29-为“异常安全”而努力是值得的" class="headerlink" title="Item 29 为“异常安全”而努力是值得的"></a>Item 29 为“异常安全”而努力是值得的</h3><p>有异常安全性的函数有：</p>
<ol>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ol>
<p>需要提供以下三个保证之一：</p>
<ol>
<li>基本承诺：异常抛出，函数内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：异常抛出，程序状态不改变。成则成，不成则返回调用之前的状态。</li>
<li>nothrow保证： 承诺绝不抛出异常。</li>
</ol>
<ul>
<li>强烈保证往往能够以 copy-and-swap实现出来，但“强烈保证”并非对所有的函数都可以实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
<h3 id="Item-30-透彻了解-inlining-的里里外外"><a href="#Item-30-透彻了解-inlining-的里里外外" class="headerlink" title="Item 30 透彻了解 inlining 的里里外外"></a>Item 30 透彻了解 inlining 的里里外外</h3><p>前提知识：inline函数的使用（头文件）</p>
<ul>
<li>inline 只是对编译器的一个申请，而不是强制命令。</li>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，是程序的速度提升机会最大。</li>
<li>不要因为function templates出现在头文件，就将他们声明为inline。</li>
</ul>
<h3 id="Item-31-将文件间的编译依存关系降至最低"><a href="#Item-31-将文件间的编译依存关系降至最低" class="headerlink" title="Item 31 将文件间的编译依存关系降至最低"></a>Item 31 将文件间的编译依存关系降至最低</h3><ul>
<li>支持“编译依存最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是Handle classed(Impl) 和 Interface classes(Factory)。</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。</li>
</ul>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="Item-32-确定你的public继承塑模出is-a的关系"><a href="#Item-32-确定你的public继承塑模出is-a的关系" class="headerlink" title="Item 32 确定你的public继承塑模出is-a的关系"></a>Item 32 确定你的public继承塑模出is-a的关系</h3><ul>
<li>适用于base classes身上的每一件事一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</li>
</ul>
<h3 id="Item-33-避免遮掩继承而来的名称"><a href="#Item-33-避免遮掩继承而来的名称" class="headerlink" title="Item 33 避免遮掩继承而来的名称"></a>Item 33 避免遮掩继承而来的名称</h3><ul>
<li>derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwarding functions)。<br>  using Base::func;</li>
</ul>
<h3 id="Item-34-区分接口继承和实现继承"><a href="#Item-34-区分接口继承和实现继承" class="headerlink" title="Item 34 区分接口继承和实现继承"></a>Item 34 区分接口继承和实现继承</h3><ul>
<li>接口继承和实现继承不同，在public之下，derived classes总是继承base class的接口。</li>
<li>pure virtual函数只具体制定接口继承。</li>
<li>非纯virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h3 id="Item-35-考虑virtual函数以外的其他选择"><a href="#Item-35-考虑virtual函数以外的其他选择" class="headerlink" title="Item 35 考虑virtual函数以外的其他选择"></a>Item 35 考虑virtual函数以外的其他选择</h3><ul>
<li>使用 non-virtual interface (NVI)手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性（private或protected）的virtual函数。</li>
<li>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。 </li>
<li>tr1::function成员变量替换virtual函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。同属Strategy。</li>
<li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</li>
</ul>
<h3 id="Item-36-绝不重新定义继承而来的non-virtual函数"><a href="#Item-36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="Item 36 绝不重新定义继承而来的non-virtual函数"></a>Item 36 绝不重新定义继承而来的non-virtual函数</h3><h3 id="Item-37-绝不重新定义继承而来的缺省参数值"><a href="#Item-37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="Item 37 绝不重新定义继承而来的缺省参数值"></a>Item 37 绝不重新定义继承而来的缺省参数值</h3><ul>
<li>因为缺省参数值都是静态绑定，而virtual函数 —— 唯一应该覆写的东西 —— 是动态绑定。</li>
</ul>
<h3 id="Item-38-通过符合塑模初has-a或“is-implemended-in-terms-of”"><a href="#Item-38-通过符合塑模初has-a或“is-implemended-in-terms-of”" class="headerlink" title="Item 38 通过符合塑模初has-a或“is-implemended-in-terms-of”"></a>Item 38 通过符合塑模初has-a或“is-implemended-in-terms-of”</h3><ul>
<li>composition的意义和public继承完全不同</li>
<li>在application domain, composition 意味着has-a。在implementation domain, composition意味着is-implemented-in-terms-of。</li>
</ul>
<h3 id="Item-39-明知而谨慎地使用private继承"><a href="#Item-39-明知而谨慎地使用private继承" class="headerlink" title="Item 39 明知而谨慎地使用private继承"></a>Item 39 明知而谨慎地使用private继承</h3><ul>
<li>Private继承意味着is-implemented-terms-of。他通常比（composition）的级别低。但是当derived class需要访问proteted base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。</li>
<li>和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
<p>EBO(empty base optimization) 空白基类最优化</p>
<pre><code>class Empty &#123;&#125;; // sizeof(Empty) == 1, C++会默默安插一个char到独立对象中
class HoldsAnInt: private Empty &#123; // sizeof(HoldsAnInt) == sizeof(int)
private:
    int x;
&#125;;
</code></pre>
<p>EBO只在单继承的情况下可以使用。</p>
<h3 id="Item-40-明知而谨慎地使用多重继承"><a href="#Item-40-明知而谨慎地使用多重继承" class="headerlink" title="Item 40 明知而谨慎地使用多重继承"></a>Item 40 明知而谨慎地使用多重继承</h3><ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小，速度，初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具使用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public 继承某个 Interface class” 和 “Private 继承某个协助实现的class” 的两相组合。</li>
</ul>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="Item-41-了解隐式接口和编译器多态"><a href="#Item-41-了解隐式接口和编译器多态" class="headerlink" title="Item 41 了解隐式接口和编译器多态"></a>Item 41 了解隐式接口和编译器多态</h3><ul>
<li>class 和 templates都支持接口和多态</li>
<li>对classes而言接口是显示的（explicit），以函数签名为中心。多态则是通过virtual函数发生与运行期。</li>
<li>对template参数而言，接口是隐式的（implicit），奠基于有效表达式。多态则是通过template具现化和函数重载解析（function overloading resolution）发生于编译器。</li>
</ul>
<h3 id="Item-42-了解typename的双重意义"><a href="#Item-42-了解typename的双重意义" class="headerlink" title="Item 42 了解typename的双重意义"></a>Item 42 了解typename的双重意义</h3><ul>
<li>声明template参数时，前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称：但不得在base class lists（基类列）或member intialization list（成员初值列）以它作为base class修饰符。</li>
</ul>
<p>ex. </p>
<pre><code>template&lt;typename T&gt;
class Derived: public Base&lt;T&gt;::Nested &#123; //base class list 中
public:
    explicit Derived(int x)
    : Base&lt;T&gt;::Nested(x) // 成员列表中
    &#123;
        typename Base&lt;T&gt;::Nested temp; // 嵌套从属类型名称
        ...
    &#125;
    ...
&#125;;
</code></pre>
<h3 id="Item-43-学习处理模板化基类内的名称"><a href="#Item-43-学习处理模板化基类内的名称" class="headerlink" title="Item 43 学习处理模板化基类内的名称"></a>Item 43 学习处理模板化基类内的名称</h3><ul>
<li>可在derived class templates 内通过“this-&gt;” 指涉base class templates内的成员名称，或藉由一个明白写出的“base class  资格修饰符”完成。</li>
</ul>
<h3 id="Item-44-将与参数无关得代码抽离templates"><a href="#Item-44-将与参数无关得代码抽离templates" class="headerlink" title="Item 44 将与参数无关得代码抽离templates"></a>Item 44 将与参数无关得代码抽离templates</h3><ul>
<li>Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li>
</ul>
<h3 id="Item-45-运用成员函数模板接受所有兼容类型"><a href="#Item-45-运用成员函数模板接受所有兼容类型" class="headerlink" title="Item 45 运用成员函数模板接受所有兼容类型"></a>Item 45 运用成员函数模板接受所有兼容类型</h3><ul>
<li>请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明 member templates 用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
<h3 id="Item-46-需要类型转换时请为模板定义非成员函数"><a href="#Item-46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="Item 46 需要类型转换时请为模板定义非成员函数"></a>Item 46 需要类型转换时请为模板定义非成员函数</h3><ul>
<li>“与此template 相关的”函数支持“所有参数之隐式类型转换”时，将那些函数定义为“class template内部的friend函数”。</li>
</ul>
<h3 id="Item-47-请使用traits-classes表现类型信息"><a href="#Item-47-请使用traits-classes表现类型信息" class="headerlink" title="Item 47 请使用traits classes表现类型信息"></a>Item 47 请使用traits classes表现类型信息</h3><ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。</li>
<li>整合重载技术（overloading）后，traits classes有可能在编译期对类型执行if…else测试。</li>
</ul>
<h3 id="Item-48-认识template元编程"><a href="#Item-48-认识template元编程" class="headerlink" title="Item 48 认识template元编程"></a>Item 48 认识template元编程</h3><ul>
<li>Template metaprogramming（TMP， 模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误错误侦测和更高的执行效率。</li>
<li>TMP可被用来生成“基于政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
<h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><p>STL容器所使用heap内存是由容器所拥有的分配器对象（allocator objects）管理，不是被new和delete直接管理</p>
<h3 id="item-49-了解new-handler的行为"><a href="#item-49-了解new-handler的行为" class="headerlink" title="item 49 了解new-handler的行为"></a>item 49 了解new-handler的行为</h3><pre><code>namespace std &#123;
    typedef void (*new_handler)();
    new_handler set_new_handler(new_handler p) throw();
&#125;
</code></pre>
<p>使用：</p>
<pre><code>void outOfMem()
&#123;
    std::cerr &lt;&lt; &quot;Unable to statify request for memory\n&quot;;
    std::abort( );
&#125;

int main()
&#123;
    std::set_new_handler(outOfMem);
    int* pBigDataArray = new int[100000000L];
    ...
&#125;
</code></pre>
<p>一个好的new-handler:</p>
<ul>
<li>让更多的内存可以使用。</li>
<li>安装另一个new-handler。</li>
<li>卸除new-handler。</li>
<li>抛出bad_alloc（或派生出自bad_alloc）的异常。</li>
<li>不返回，通常调用abort或者exit</li>
</ul>
<blockquote>
<p>CRTP (curiously recurring template pattern) 怪异的循环模式，Widget继承自一个模板化的base class，后者又以Widget作为类型参数。可以用来添加set_new_handler支持。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>set_new_handler允许客户制定一个函数，在内存分配无法获得满足时被调用。</li>
<li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常。</li>
</ul>
<p>ex.</p>
<pre><code>Widget* pw2 = new (std::nothrow) Widget;
</code></pre>
<h3 id="Item-50-了解new和delete的合理替换时机"><a href="#Item-50-了解new和delete的合理替换时机" class="headerlink" title="Item 50 了解new和delete的合理替换时机"></a>Item 50 了解new和delete的合理替换时机</h3><ul>
<li>用来检测运用上的错误</li>
<li>为了强化效能</li>
<li>为了收集使用上的统计数</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的额外开销</li>
<li>为了弥补缺省分配器中的非最佳齐位</li>
<li>为了将相关对象成簇集中</li>
<li>为了获得非传统的行为</li>
</ul>
<h3 id="Item-51-编写new和delete时需要固守常规"><a href="#Item-51-编写new和delete时需要固守常规" class="headerlink" title="Item 51 编写new和delete时需要固守常规"></a>Item 51 编写new和delete时需要固守常规</h3><ul>
<li>operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果他无法满足内存需求，就该调用new-handler。它也应该有能力处理 0 byte 申请。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
<li>operator delete 应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
</ul>
<h3 id="Item-52-写了placement-new-也要写-placement-delete"><a href="#Item-52-写了placement-new-也要写-placement-delete" class="headerlink" title="Item 52 写了placement new 也要写 placement delete"></a>Item 52 写了placement new 也要写 placement delete</h3><ul>
<li>请不要无意识的遮掩正常版本的new和delete</li>
</ul>
<h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h3 id="Item-53-不要轻视编译器的警告"><a href="#Item-53-不要轻视编译器的警告" class="headerlink" title="Item 53 不要轻视编译器的警告"></a>Item 53 不要轻视编译器的警告</h3><h3 id="Item-54-让自己熟悉包括-TR1-在内的标准程序库-（最新的版本不太需求）"><a href="#Item-54-让自己熟悉包括-TR1-在内的标准程序库-（最新的版本不太需求）" class="headerlink" title="Item 54 让自己熟悉包括 TR1 在内的标准程序库 （最新的版本不太需求）"></a>Item 54 让自己熟悉包括 TR1 在内的标准程序库 （最新的版本不太需求）</h3><h3 id="Item-55-让自己熟悉-Boost"><a href="#Item-55-让自己熟悉-Boost" class="headerlink" title="Item 55 让自己熟悉 Boost"></a>Item 55 让自己熟悉 Boost</h3><p>Boost： C++标准库的候选者们</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/program/">program</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/cpp/">cpp</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://galaxy2416.github.io/2018/02/23/cpp-effective/" data-title="Effective C++ | IcePie&#39;s blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/07/17/github_ssh/" title="github ssh key set">
  <strong>上一篇：</strong><br/>
  <span>
  github ssh key set</span>
</a>
</div>


<div class="next">
<a href="/2017/07/11/arobot2/"  title="2016-2017总结，ART-1,2 - 我与我们所做的事情">
 <strong>下一篇：</strong><br/> 
 <span>2016-2017总结，ART-1,2 - 我与我们所做的事情
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="galaxy2416" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/51单片机/" title="51单片机">51单片机<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/avr系列/" title="avr系列">avr系列<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/math/" title="math">math<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/program/" title="program">program<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/simple-robots-系列/" title="simple robots 系列">simple robots 系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/vim/" title="vim">vim<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/仿人机器人/" title="仿人机器人">仿人机器人<sup>4</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/git-ssh/" title="git ssh">git ssh<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Valkyrie/" title="Valkyrie">Valkyrie<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/artrobot/" title="artrobot">artrobot<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Atlas/" title="Atlas">Atlas<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/cpp/" title="cpp">cpp<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/robot/" title="robot">robot<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/第一篇文章/" title="第一篇文章">第一篇文章<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Romeo/" title="Romeo">Romeo<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://sherlockyu.github.io" target="_blank" title="猫哥的小博客">于小猫</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m IcePie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/galaxy2416" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:gin@mail.elut.edu.cn" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021 
		
		<a href="/about" target="_blank" title="冰派">冰派</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'galaxy2416';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
